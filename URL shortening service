1. Requirements

Functional Requirements:
Accept a long URL and return a shortened URL.
Redirect users from the shortened URL to the original URL.
Track metrics such as the number of clicks on the shortened URL.
Allow users to manage their shortened URLs (e.g., delete, update).


Non-Functional Requirements:
Scalability: The system should handle a large number of requests.
Availability: The service should be highly available.
Performance: URL shortening and redirection should be fast (low latency).
Security: Prevent abuse (e.g., spamming, phishing).


2. High-Level Design

Components:
API Gateway: To handle incoming requests.
Application Server: To process requests and perform business logic.
Database: To store original URLs and their corresponding shortened versions.
Cache: To store frequently accessed URLs for quick redirection.
Analytics Service: To track and report metrics.


3. Detailed Design

Data Model:
URL Mapping Table:
id (Primary Key)
original_url (String)
shortened_url (String)
created_at (Timestamp)
click_count (Integer)


Shortening Logic:
Generate a unique identifier (e.g., base62 encoding) for each URL.
Map the identifier to the original URL in the database.
Example: For a long URL like https://example.com/some/long/path, generate a shortened version like https://short.ly/abc123.


Redirection Logic:
When a user accesses a shortened URL, look up the identifier in the database.
Redirect the user to the original URL.



4. Scalability and Performance

Techniques:
Caching: Use an in-memory cache (like Redis) to store frequently accessed URLs to reduce database load.
Load Balancing: Distribute incoming requests across multiple application servers.
Database Sharding: Split the database into smaller parts to handle larger datasets.



5. Security and Compliance

Validation: Validate URLs before storing them to prevent malicious content.
Rate Limiting: Implement rate limiting to prevent abuse of the service.
HTTPS: Use HTTPS to encrypt data in transit.



6. Monitoring and Maintenance

Logging: Implement logging for both successful and failed requests.
Analytics: Track metrics like the number of clicks and the most popular URLs.
Health Checks: Regularly check the health of services and databases.



7. API Endpoints

POST /shorten
  Request Body: { "original_url": "https://example.com/some/long/path" }
  Response: { "shortened_url": "https://short.ly/abc123" }

GET /:shortened_url
  Redirects to the original URL.

GET /stats/:shortened_url
Response: { "click_count": 100, "created_at": "2023-01-01T00:00:00Z" 

--------------------------------------------------------------------------------------------------------------

Back of the envelope calculation 

1. User Base and Activity
Daily Active Users (DAU) : 50,000 Users
Per User - Average Shortening Requests/Day  : 3 Request/Day
Per User - Average Redirecting Requests/Day : 5 Requesr/Day


2. Request Volume Estimation
Total Shortening Requests/Day  = 50,000 * 3 = 150,000 Requests/Day
Total Redirecting Requests/Day = 50,000 * 5 = 250,000 Requests/Day

Total Shortening Requests/Second = 150,000 / (24*60*60)= 150,000 / 86,400 = 1.736 Requests/Second
Total Redirecting Requests/Second = 250,000 / (24*60*60) = 250,000 / 86,400 = 2.893 Requests/Second

so Total Requests/Second (RPS) = 1.736 Requests/Second + 2.893 Requests/Second = 4.63 Requests/Second


3. Database Queries Calculation
Shortening Requests has 3 queries (insert, select, update)
Redirecting Request has 2 queries (select, update)

Total Queries Per Second for Shortening Requests = [(1.736 Requests/Second) * 3 queries] = 5.208
Total Queries Per Second for Redirecting Requests = [(2.893 Requests/Second) * 2 queries] = 5.786

so Total Queries Per Second = 5.208 + 5.786 = 10.994 = 11 Queries/Second


4. Latency and Performance
Shortening Requests has 3 queries
Redirecting Request has 2 queries

We estimated the latency for each query to be 20 ms.
We estimated Network Latency of 30 ms.
*****






5. Storage Requirements Estimation
Average URL Length: 100 characters (assume)
Short URL Length: 10 characters (assume)
Overhead: 50 bytes (assume)

Total Size per URL = 100+10+50 = 160 bytes
so Total storage / Day = 160 * Total Requests/day = 160 * [150,000 + 250,000] = 160 * 400,000 = 64,000,000 bytes = 64,000,000 / 1,024,000 = 62.5 MB
so Total storage / Year = 365 * 160 * 400,000 bytes 
so Total storage / 5 Year = 5 * 365 * 160 * 400,000 bytes = 114062.5 MB (divide by 1024000)





























